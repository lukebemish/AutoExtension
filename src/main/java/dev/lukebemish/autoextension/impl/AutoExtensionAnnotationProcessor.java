package dev.lukebemish.autoextension.impl;


import com.google.auto.service.AutoService;
import dev.lukebemish.autoextension.AutoExtension;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Properties;
import java.util.Set;

/**
 * An annotation processor for the {@link AutoExtension} annotation.
 */
@SupportedAnnotationTypes("dev.lukebemish.autoextension.AutoExtension")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
@AutoService(Processor.class)
@SuppressWarnings("unused")
@SupportedOptions({"autoextension.name", "autoextension.version"})
public class AutoExtensionAnnotationProcessor extends AbstractProcessor {
    private final Set<String> extensions = new HashSet<>();
    private final Set<String> staticExtensions = new HashSet<>();

    private static final String INSTANCE_CLASSES_KEY = "extensionClasses";
    private static final String STATIC_CLASSES_KEY = "staticExtensionClasses";

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (roundEnv.processingOver()) {
            generateExtensionMetaFiles();
        } else {
            processAnnotated(annotations, roundEnv);
        }
        return false;
    }

    private void generateExtensionMetaFiles() {
        String name = processingEnv.getOptions().get("autoextension.name");
        String version = processingEnv.getOptions().get("autoextension.version");

        Filer filer = processingEnv.getFiler();
        String resourceFile = "META-INF/groovy/org.codehaus.groovy.runtime.ExtensionModule";
        Properties properties = new Properties();
        try {
            FileObject existingFile = filer.getResource(StandardLocation.CLASS_OUTPUT, "", resourceFile);
            properties.load(existingFile.openInputStream());
        } catch (IOException e) {
            try {
                FileObject existingFile = filer.getResource(StandardLocation.SOURCE_PATH, "", resourceFile);
                properties.load(existingFile.openInputStream());
            } catch (IOException ignored) {
                // ignore
            }
        }
        Set<String> outNonStatic = new HashSet<>(extensions);
        Set<String> outStatic = new HashSet<>(staticExtensions);

        outNonStatic.addAll(Arrays.asList(properties.getProperty(INSTANCE_CLASSES_KEY, "").trim().split("[,; ]")));
        outStatic.addAll(Arrays.asList(properties.getProperty(STATIC_CLASSES_KEY, "").trim().split("[,; ]")));

        outNonStatic.removeIf(String::isBlank);
        outStatic.removeIf(String::isBlank);

        properties.setProperty(INSTANCE_CLASSES_KEY, String.join(",", outNonStatic));
        properties.setProperty(STATIC_CLASSES_KEY, String.join(",", outStatic));

        if (name != null && !name.isBlank())
            properties.setProperty("moduleName", name);
        if (version != null && !name.isBlank())
            properties.setProperty("moduleVersion", version);

        try {
            FileObject fileObject =
                    filer.createResource(StandardLocation.CLASS_OUTPUT, "", resourceFile);
            try (OutputStream out = fileObject.openOutputStream()) {
                properties.store(out, "Generated by AutoExtension");
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void processAnnotated(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(AutoExtension.class);
        for (Element e : elements) {
            AutoExtension extension = e.getAnnotation(AutoExtension.class);
            String className = ((TypeElement) e).getQualifiedName().toString();
            (extension.isStatic() ? staticExtensions : extensions).add(className);
        }
    }
}
